import streamlit as st
import pandas as pd
import numpy as np
import datetime as dt
import os
from datetime import datetime
import html  # kamu pakai di explain_headline_lime

# scipy
from scipy.sparse import hstack
from scipy.stats import spearmanr, pearsonr
from scipy.sparse import csr_matrix, hstack

# text and features
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.decomposition import TruncatedSVD

# preprocessing & modeling
from sklearn.preprocessing import StandardScaler, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.pipeline import Pipeline
from sklearn.linear_model import LinearRegression
from sklearn.metrics import mean_absolute_error, mean_squared_error, r2_score
from sklearn.preprocessing import StandardScaler
from sklearn.decomposition import PCA
from sentence_transformers import SentenceTransformer
from lime.lime_text import LimeTextExplainer

# library xgboost
import xgboost as xgb

# Shap
import shap


# Joblib
import joblib

# timedelta
from datetime import timedelta

# optuna
import optuna

# scrapping data finance
import yfinance as yf

# time split
from sklearn.model_selection import train_test_split

# for OLS statistics
import statsmodels.api as sm

# Google Translator
from deep_translator import GoogleTranslator

# Hugging Face sentiment pipeline
import torch
from transformers import pipeline
from transformers import AutoTokenizer, AutoModelForSequenceClassification
from transformers import BertTokenizer, BertForSequenceClassification
import torch.nn.functional as F

# visualizations
import matplotlib.pyplot as plt
import seaborn as sns
sns.set()

cache = {}

def get_data(ticker):
    if ticker not in cache:
        cache[ticker] = yf.download(f"{ticker}.JK", start="2023-01-01", end="2025-07-29", progress=False)
    return cache[ticker]

def vol(ticker, start, end):
    stock = yf.download(f"{ticker}.JK",
                        start=str(start.date()),
                        end=str(end.date()),
                        progress=False)

    if stock.empty or len(stock) < 3:
        return np.nan

    stock['return'] = stock['Close'].pct_change()
    vol_series = stock['return'].rolling(7).std()

    # Ambil yang terakhir
    vol_value = vol_series.iloc[-1]

    # 2Ô∏è‚É£ Kalau hasil NaN ‚Üí fallback ke 30 hari sebelum end_date
    if pd.isna(vol_value):
        fallback_start = end - timedelta(days=30)
        stock2 = yf.download(f"{ticker}.JK",
                             start=str(fallback_start.date()),
                             end=str(end.date()),
                             progress=False)

        if not stock2.empty and len(stock2) >= 7:
            stock2['return'] = stock2['Close'].pct_change()
            vol_value = stock2['return'].rolling(7).std().iloc[-1]

    # 3Ô∏è‚É£ Kalau masih NaN ‚Üí pakai std dari seluruh return
    if pd.isna(vol_value):
        vol_value = stock['return'].std()

    return vol_value

def avg_price(ticker, start_date, end_date):
  # Download harga saham sesuai timeframe baris
  stock = yf.download(f"{ticker}.JK",
                      start=str(start_date.date()),
                      end=str(end_date.date()),
                      progress=False)

  # Kalau data kosong ‚Üí return NaN
  if stock.empty:
    return np.nan
  avg = stock['Close'].mean()
  # Hitung rata-rata harga penutupan pada range tersebut
  return float(avg[0])

def translate_to_en(text):
    try:
        return GoogleTranslator(source='auto', target='en').translate(text)
    except:
        return ""

def build_lime_explainer(sent_model, model, num_feat_dim):
    """Return a LimeTextExplainer and a wrapper prediction function that accepts list[str].
    The wrapper encodes text to embeddings, attaches zeros (or provided numeric context later),
    and returns predictions.
    """
    explainer = LimeTextExplainer(class_names=['rate'])

    def predict_texts(texts, numeric_context=None):
        # texts: list[str]; numeric_context: None -> zeros; or array shape (len(texts), num_feat_dim)
        embs = sent_model.encode(texts, convert_to_numpy=True)
        if numeric_context is None:
            num0 = np.zeros((len(embs), num_feat_dim))
        else:
            # Repeat numeric_context for each sample generated by LIME
            num0 = np.repeat(np.asarray(numeric_context), len(embs), axis=0)
        X_in = np.hstack([embs, num0])
        # Reshape the output to be 2D as LIME expects (n_samples, n_classes), even for single regression output
        return model.predict(X_in).reshape(-1, 1)

    return explainer, predict_texts


def explain_headline_lime(headline, sent_model, lime_explainer, predict_texts, num_feat_vals=None, num_features=10):
    """Return list of (word_phrase, contribution) from LIME & HTML highlighted text.
    num_feat_vals: if provided, should be shape (1, num_feat_dim) to include numeric context.
    """
    # LIME explain_instance expects a function taking list[str] and returning numpy preds
    func_for_lime = lambda texts: predict_texts(texts, numeric_context=num_feat_vals)
    # Explicitly set labels=[0] to avoid IndexError for single output regression
    exp = lime_explainer.explain_instance(headline, func_for_lime, labels=[0], num_features=num_features)
    contributions = exp.as_list(label=0)  # list of (phrase, weight)

    # Build HTML highlight: positive -> green, negative -> red; scale weights
    # We'll map phrase contributions to tokens by simple substring matching (LIME returns substrings)
    safe_headline = html.escape(headline)
    parts = safe_headline.split()

    # Normalize weights for coloring
    weights = [abs(w) for (_, w) in contributions] if contributions else [0.0]
    maxw = max(weights) if max(weights) > 0 else 1.0
    phrase_to_w = {phrase: weight for (phrase, weight) in contributions}

    highlighted = []
    for tok in parts:
        tok_clean = tok.strip('.,!?:;"\'')
        # find contribution for tok (substring match)
        w = 0.0
        sign = 0
        for phrase, wt in phrase_to_w.items():
            # match ignoring case
            if phrase.lower() in tok_clean.lower():
                w = wt
                sign = 1 if wt > 0 else -1
                break
        if w == 0.0:
            highlighted.append(tok)
        else:
            intensity = min(1.0, abs(w) / maxw)
            # compute simple rgba alpha based on intensity
            alpha = 0.2 + 0.8 * intensity
            if sign > 0:
                style = f'background: rgba(0,128,0,{alpha}); padding:0 2px; border-radius:3px'
            else:
                style = f'background: rgba(255,0,0,{alpha}); padding:0 2px; border-radius:3px'
            highlighted.append(f"<span style=\"{style}\">{tok}</span>")

    html_out = ' '.join(highlighted)
    return contributions, html_out

from datetime import timedelta
import numpy as np
import html

def predict_headline_with_ticker(
    headline, ticker, start_date, end_date, price_before,
    model, scaler, sent_model,
    lime_explainer=None, predict_texts=None, explain=False
):
    """
    Prediksi rate_pct_log untuk 1 headline baru berdasarkan ticker & periode.

    Parameters
    ----------
    headline : str
        Headline berita.
    ticker : str
        Kode saham tanpa '.JK' (contoh: 'BBCA')
    start_date, end_date : datetime
        Range tanggal untuk ambil data harga & volatilitas.
    price_before : float
        Harga saham sebelum berita.
    model : trained XGBRegressor
    scaler : fitted StandardScaler
    sent_model : SentenceTransformer
    lime_explainer, predict_texts : optional
        Untuk menampilkan LIME highlight kalau explain=True
    explain : bool
        True ‚Üí tampilkan highlight HTML LIME

    Returns
    -------
    pred : float
        Prediksi rate_pct_log
    """

    # 1Ô∏è‚É£ Ambil data numeric features
    headline_en = translate_to_en(headline)
    vol_value = vol(ticker, start_date, end_date)
    avg_val = avg_price(ticker, start_date, end_date)

    if np.isnan(vol_value) or np.isnan(avg_val):
        print("‚ö†Ô∏è Data harga tidak cukup lengkap, hasil mungkin kurang akurat.")

    # 2Ô∏è‚É£ Hitung price change
    price_change_pct = (avg_val - price_before) / price_before if price_before != 0 else 0.0

    # 3Ô∏è‚É£ Gabungkan ke numeric feature dan scaling
    num_feats = np.array([[vol_value, price_change_pct]])
    num_feats_scaled = scaler.transform(num_feats)

    # 4Ô∏è‚É£ Encode headline_en
    emb = sent_model.encode([headline_en], convert_to_numpy=True)
    X_in = np.hstack([emb, num_feats_scaled])

    # 5Ô∏è‚É£ Prediksi
    pred = float(model.predict(X_in)[0])

    print("üì∞ headline_en:", headline_en)
    print(f"üìä Predicted rate_pct_log: {pred:.6f}")
    print(f"üìà Volatility: {vol_value:.6f}, Avg price: {avg_val:.2f}, Price change: {price_change_pct:.4f}")

    # 6Ô∏è‚É£ Optional LIME Explanation
    if explain and lime_explainer is not None and predict_texts is not None:
        contributions, html_highlight = explain_headline_lime(
            headline_en,
            sent_model,
            lime_explainer,
            predict_texts,
            num_feat_vals=num_feats_scaled,
            num_features=10
        )
        st.session_state["lime_contrib"]=contributions
        # Simpan HTML hasil
    pred_exp = np.sign(pred)*(np.expm1(abs(pred)))
    pred_percent = round(pred_exp, 3)
    return pred_percent

def load_all_models():
    scaler = joblib.load(SCALER_PATH)
    xgb_model = xgb.XGBRegressor()
    xgb_model.load_model(MODEL_PATH)
    emb_model = SentenceTransformer(EMBED_MODEL_NAME)
    return scaler, xgb_model, emb_model

headline = "Laba Bersih ACES Hardware (ACES) Kuartal I 2025 Tumbuh 12%"
BASE_DIR = os.path.dirname(os.path.abspath(__file__))
SCALER_PATH = os.path.join(BASE_DIR, "scaler.pkl")
MODEL_PATH = os.path.join(BASE_DIR, "xgb_text_model.json")
ticker = "ACES"
EMBED_MODEL_NAME = 'all-MiniLM-L6-v2'
num_feat_dim = 2
scaler = joblib.load(SCALER_PATH)
xgb_model = xgb.XGBRegressor()
xgb_model.load_model(MODEL_PATH)
emb_model = SentenceTransformer(EMBED_MODEL_NAME) 
lime_explainer, predict_texts = build_lime_explainer(emb_model, xgb_model, num_feat_dim)
start_date = datetime(2025, 4, 30)
end_date = datetime(2025, 5, 30)
price_before = 800.0  # harga sebelum periode itu (misal harga penutupan akhir September)
pred = predict_headline_with_ticker(
    headline=headline,
    ticker=ticker,
    start_date=start_date,
    end_date=end_date,
    price_before=price_before,
    model=xgb_model,
    scaler=scaler,
    sent_model=SentenceTransformer(EMBED_MODEL_NAME),
    lime_explainer=lime_explainer,
    predict_texts=predict_texts,
    explain=True
)